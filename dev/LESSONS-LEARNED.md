# Lessons Learned (Project-Wide)

> This file accumulates lessons learned from ALL features and fixes. Each entry
> is append-only and dated. It is okay for this file to be empty when first
> created.

---

## Entries

<!--
Add entries in this format:

- [YYYY-MM-DD] Short lesson description (optional link to PR/commit/path)
-->

- [2025-11-15] Curl multiline JSON payloads: Inline JSON with unescaped newlines causes "blank argument" errors. Solution: Use `cat > /tmp/file.json << 'EOF'` with heredoc syntax, then reference with `-d @/tmp/file.json`. This is more readable and maintainable than trying to escape special characters in inline JSON. (feature/mission-comm-planning: d8902f1)
- [2025-11-16] Docker layer caching bypasses code changes: Always use `docker compose down && docker compose build --no-cache && docker compose up -d` when Python code changes. Simply running `docker compose up` or `docker compose restart` will serve cached code from previous builds, making changes appear ineffective. This is critical for test execution and verification. (feature/mission-comm-planning: d8fd695)
- [2025-11-16] Time management in Docker rebuilds: Docker rebuilds take 60–90 seconds. Using `sleep 30+` wastes time waiting. Optimal: `sleep 5` then check `docker compose ps` for healthy status. This saves ~25 seconds per rebuild cycle during iterative testing. (feature/mission-comm-planning: 3fe0c84)
- [2025-11-16] Benchmark script dependencies: Performance benchmarking scripts must pre-create or load test data (routes, missions) before timeline computations. RouteManager uses in-memory `_routes` dict; test routes must exist before build_mission_timeline() is called. Solution: Initialize managers, then `route_manager._routes[route_id] = Route(...)` to inject test data. (feature/mission-comm-planning: Session 9)
- [2025-11-17] ParsedRoute object structure: `ParsedRoute` objects from `RouteManager.get_active_route()` do not have a direct `.id` attribute. Route IDs must be extracted from `route.metadata.file_path` using `Path(file_path).stem`. Attempting to access `route.id` will cause AttributeError. This was discovered when implementing active status calculation for route-associated POIs. Solution: `active_route_id = Path(active_route.metadata.file_path).stem` (feat/poi-active-field)
- [2025-11-17] Mission model design pattern: Mission models store `route_id` (string ID), NOT a `route` object. This is by design for loose coupling. When you need route data, you must fetch it from RouteManager using `route_manager.get_route(mission.route_id)`. Similarly, never assume related objects are populated; fetch them from their respective managers. This pattern applies across routes, POIs, and other related entities. Discovered when implementing map generation for exports—code tried `mission.route` which doesn't exist. Solution: Pass RouteManager instance to exporter, use global variable with setter function pattern (main.py calls `exporter.set_route_manager()`), then `route = _route_manager.get_route(mission.route_id)`. (feat/excel-sheet1-timeline-summary: 7158620)
- [2025-11-18] Cartopy IDL-crossing routes require projection center calculation: When displaying routes that cross the International Date Line (e.g., Korea to Washington DC), cartopy's PlateCarree projection must use an appropriate `central_longitude` parameter to center the map in the correct location. Hard-coding to 180° (Pacific center) is wrong for all routes. Solution: Calculate center from route bounds: `bounds_center_lon = (bounds_west + bounds_east) / 2`, then use `PlateCarree(central_longitude=bounds_center_lon)`. However, when using calculated central_longitude, extent coordinates must be shifted to match the projection's coordinate system, which is complex and error-prone. Alternative: Consider skipping Pacific-centering for initial Phase 8 and use standard PlateCarree(), only adding advanced centering if explicitly needed. The NaN/Inf axis errors encountered suggest coordinate shifting calculation is fragile. (feat/excel-sheet1-timeline-summary: Session 2 - Phase 8 debugging)
- [2025-11-22] Asset file paths in checklists: When planning term replacements, verify actual file locations in the codebase before committing to checklist paths. The HCX.kmz file was documented as `data/sat_coverage/HCX.kmz` but actually exists at `backend/starlink-location/app/satellites/assets/HCX.kmz`. Always check main.py or relevant code to confirm asset loading paths. (chore/term-replacements)
- [2025-11-22] Term replacement test verification: When executing large-scale term replacements (HCX→CommKa, WGS→X-Band), run full test suite to verify changes. A 96%+ pass rate with failures unrelated to term changes indicates successful replacement. Pre-existing test failures should be documented but don't block the term-replacement PR. (chore/term-replacements: 721/750 tests passed, 7 failures pre-existing)
- [2025-11-22] POI persistence across Docker rebuilds: POI names and data are persisted in `/data/pois.json` after Docker container rebuilds. When testing new POI generation logic (e.g., name simplification), test data from previous runs will conflict with verification. Solution: Explicitly delete `/data/pois.json` before Docker rebuild to verify fresh POI generation from new code, or test against newly created missions. This applies to all POI-related features. (feat/simplify-swap-poi-names)
- [2025-11-22] Mission API workflow for testing: Missions are not auto-generated; they must be explicitly created via POST `/api/missions` endpoint. After code changes affecting mission metadata or POI generation, verification requires creating a test mission to observe new behavior. Sample: `curl -X POST -H "Content-Type: application/json" -d '{"name":"Test","route_id":"simple-circular"}' http://localhost:8000/api/missions`. This applies to all mission-related features. (feat/simplify-swap-poi-names)
- [2025-11-22] Export endpoints require POST method: All export endpoints (CSV, XLSX, PDF, PPTX) use POST method, not GET. Example: `curl -X POST http://localhost:8000/api/missions/{mission_id}/export/csv`. This is important for verification scripting and API testing. Attempting GET will fail silently or return incorrect results. (feat/simplify-swap-poi-names)
- [2025-11-23] Sub-agent naming deviations: When delegating tasks to sub-agents with exact code specifications (function names, variable names), agents may use "better" or "clearer" names that deviate from the specification. This breaks downstream code that references the exact names. Solution: Emphasize in delegation prompts to "use EXACTLY the names specified" and verify function names match after agent completion. Example: Checklist specified `get_mission_path()` but agent used `get_mission_directory()`, which would break subsequent code calling `get_mission_path()`. (feat/mission-leg-planning-ui: task 1.5)
- [2025-11-23] cd command incompatibility with zoxide: The `cd` command with directory arguments fails in environments with zoxide installed. Solution: Use absolute paths with commands instead of changing directories. Example: Instead of `cd backend/starlink-location && pytest tests/`, use `pytest /home/brian/Projects/starlink-dashboard-dev/backend/starlink-location/tests/`. (feat/mission-leg-planning-ui: task 1.8)
- [2025-11-23] Python tests require proper environment: Python tests cannot be run directly on the host without activating the virtual environment. Solution: Run tests inside the Docker container using `docker exec starlink-location pytest /app/tests/ -v` to ensure correct Python environment and dependencies. Alternative (faster): Use venv with absolute paths to avoid Docker rebuild delays. (feat/mission-leg-planning-ui: task 1.8)
- [2025-11-23] Venv is faster for testing than Docker rebuilds: When iterating on Python code changes, using the venv directly avoids 60-90 second Docker rebuild cycles. Docker rebuilds are only necessary for final verification or when dependencies change. For rapid test iteration during development, prefer venv: `source backend/starlink-location/venv/bin/activate && pytest /abs/path/to/tests/ -v`. (feat/mission-leg-planning-ui: task 1.8)
- [2025-11-23] npm create vite path handling: When using npm create vite with an absolute path, the tool may duplicate the path structure if not careful. Solution: Use the target directory path correctly with the `--` separator. Example: `npm create vite@latest frontend/mission-planner -- --template react-ts` works correctly from project root. Avoid nesting absolute paths within the command. (feat/mission-leg-planning-ui: task 3.1)
- [2025-11-23] Tailwind CSS v4 PostCSS plugin change: Tailwind v4 no longer exports a PostCSS plugin directly from the `tailwindcss` package. Solution: Install `@tailwindcss/postcss` separately and configure it in `postcss.config.js` with `plugins: ['@tailwindcss/postcss']`. The `@tailwind` directives still work in CSS files. (feat/mission-leg-planning-ui: task 3.3)
- [2025-11-23] npx with --prefix and interactive commands: Interactive npm commands (like `npx shadcn@latest init`) don't work with `npx --prefix` because npm doesn't properly handle stdin piping with that flag. Solution: Manually create configuration files (components.json) with expected defaults and install dependencies separately, or cd into the directory first. (feat/mission-leg-planning-ui: task 3.3)
- [2025-11-23] Check backend API endpoints first: Before implementing UI components, verify backend API endpoints and data models to understand expected data structures. This prevents having to refactor components later when discovering misalignment (e.g., X-Band transitions needed lat/lon not waypoint indices, AAR segments only needed start/end waypoints, Ka/Ku outages needed time frames not waypoint ranges). Solution: Review backend models and API contracts before building forms and tables. (feat/mission-leg-planning-ui: Phase 5)
- [2025-11-24] React-Leaflet MapContainer ref incompatibility: MapContainer from react-leaflet doesn't accept standard React refs via `ref={mapRef}`. This causes React error #310 (rendering/hydration issue). Solution: Use the `useMap` hook from react-leaflet inside a child component to access the map instance. Create a MapController component that calls `const map = useMap()` and use `useEffect` to interact with the map. This is the recommended pattern for accessing the Leaflet map instance in React. (feat/mission-leg-planning-ui: Phase 6.5)
- [2025-11-24] Verify existing API patterns before creating new ones: When asked to create CRUD operations for a domain, first check if the backend already has an established pattern for that data. Creating incompatible parallel systems causes integration issues. Example: Satellite system already existed with read-only catalog API at `/api/satellites`, but we created a new CRUD service that conflicted. Solution: Search codebase for existing endpoints (`rg "@router" backend/`) and review established patterns before implementing new services. (feat/mission-leg-planning-ui: Phase 6.5)
- [2025-11-24] X-Band satellites are POIs not database entities: In this codebase, X-Band satellites are stored as POIs with `category="satellite"`, `latitude=0` (equator), and only `longitude` varies (geostationary). The `/api/satellites` endpoint returns the catalog for display/selection, not for CRUD operations. To add custom X-Band satellites, users should create POIs through the POI system. The satellite manager should be read-only, displaying catalog entries. (feat/mission-leg-planning-ui: Phase 6.5)
- [2025-11-25] Satellite manager CRUD integration with POI system: When building a satellite manager with CRUD operations, integrate it with the existing POI system by filtering POIs with `category="satellite"`. Satellites should be created as POIs with `latitude=0` (geostationary equator), `longitude` as the varying field, and `name` as the satellite ID. Use dependency injection (`set_poi_manager()`) to pass the POI manager to satellite routes. This maintains a unified storage system while providing specialized satellite management UI. Color mapping by transport type (X/Ka/Ku) can be automated based on the `icon` field. (feat/mission-leg-planning-ui: Phase 6.5)
- [2025-11-25] AAR segment visualization requires waypoint names array: When rendering route segments (AAR, restricted zones, etc.) on a map, you must pass the waypoint names array to enable proper start/end point matching. Without waypoint names, you cannot slice the coordinate array correctly - waypoint indices are required to extract the specific segment. Use case-insensitive trimmed string matching (`name.trim().toLowerCase()`) to handle variations in waypoint name formatting. The coordinate array index corresponds to the waypoint array index. This pattern applies to any feature that needs to highlight a portion of a route based on named waypoints. (feat/mission-leg-planning-ui: Phase 6.5)
- [2025-11-25] Waypoint array indices do NOT correspond to coordinate array indices: Route coordinates arrays contain ALL continuous points from LineString geometry (e.g., 1000+ points), while waypoint arrays contain only named placemarks (e.g., 5-10 points). Do NOT assume waypoint array index N maps to coordinates array index N. Instead, use haversine distance calculation to find the closest coordinate to each waypoint's lat/lon position. This applies to any feature that needs to map named waypoints to specific positions in a continuous route (AAR segments, restricted zones, checkpoints, etc.). (feat/mission-leg-planning-ui: Phase 6.5)
- [2025-11-25] Backend timeline segments don't include coordinates by default: The TimelineSegment model in the backend doesn't have latitude/longitude fields. While the timeline_service calculates coordinates during processing, they're not persisted in the final segment model. Frontend extraction logic should gracefully handle missing coordinates and log discoveries for future enhancement. Timeline marker visualization requires coordinates; without them, markers won't render (e.g., Ka transitions parse correctly but need coordinates to display on map). This is a known limitation that should be addressed by extending the TimelineSegment model to include optional coordinate fields. (feat/mission-leg-planning-ui: Ka transition visualization)
